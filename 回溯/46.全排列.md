### 46.全排列

**问题分析**

给定一个不重复的 nums 数组，返回所有可能的全排列。

典型全排列，全排列包含数组的所有数字，长度和 nums 一样

将返回 res 的每一个数字当作一层，先从一条线一直遍历到最后一层，将最后一层遍历结束后再返回上一层换路径，有点类似于二叉树的递归遍历



**代码实现**

```go
func permute(nums []int) [][]int {
	res := make([][]int, 0)
	length := len(nums)
    // 因为会直接对某个位置进行访问和修改，所以需要在实例化的时候生命长度
	path := make([]int, length)
	record := make(map[int]int, 0)
	for _, c := range nums {
		record[c]++
	}
    
	var dfs func(int)
	dfs = func(i int) {
        // 0 到 length-1 才是有效位，这里已经超出了
        // 将当前 path 添加到 res ，然后退出
		if i == length {
            // ！！！添加到slice实际上是引用，如果后续修改外部变量的话，会对slice内部数据同步修改
            // 所以这里创建新 slice 将元素添加进去
			res = append(res, append([]int{}, path...))
			return
		}
		for c, counter := range record {
            // 只有counter大于0的时候，才代表这个c是可以在这一层被使用的
			if counter > 0 {
				path[i] = c
				record[c]--
				dfs(i + 1)
                //回溯，在下一层的 dfs 结束后，需要回溯恢复之前的情况
				record[c]++
			}
		}
	}
	dfs(0)
	return res
}
```

